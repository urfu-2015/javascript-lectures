## Хостинг
Рассмотрим пример:

``` javascript
a = 2;

var a;

console.log( a );
```
Как вы думаете, что будет в результате `console.log(..)`?
Многие разработчики ожидают `undefined`, так как объявление переменной приходит после `а = 2`, и, казалось бы естественно предположить, что переменная заново переопределяется, и, таким образом присваивается по умолчанию `undefined`. Тем не менее, на выходе будет 2.

Рассмотрим еще один кусок кода:
``` javascript
console.log( a );

var a = 2;
```

Вы могли бы предположить, что в этом фрагменте на консоли будет 2. Другие могут подумать, что, поскольку переменная используется, прежде чем он объявлена, это должно привести к ReferenceError. Оба варианта неправильные, на консоли будет `undefined`.

Так что же здесь происходит?

### Компилятор
Обратимся к предыдущей лекции, к той части в которой мы говорили про компиляторы. Напомним, что интерпритатор будет компилировать ваш код, прежде чем его выполнит. Одним из этапов компиляции является поиск объявлений всех переменных и ассоциация их с соответствующей облостью видимости.

Для простоты положим, что оба вида объявлений, как функций, так и переменных происходят одновременно, до того как выполнится код.

Когда вы видите объявление переменной `var а = 2;`, вы, наверное, воспринимаете это как один оператор. Но JavaScript на самом деле думает о нем, как о двух операторах: `var a;`и `a = 2;`. Первый оператор, декларация, обрабатывается на этапе компиляции. Второй оператор, присваивание, остается на месте до фазы выполнения.

Наш первый пример следует понимать так:
``` javascript
var a;
```
``` javascript
a = 2;

console.log( a );
```
Где первая часть это копиляция, а вторая часть - выполнение.

Аналогично, второй листинг обрабатывается следующим образом:
``` javascript
var a;
```
``` javascript
console.log( a );

a = 2;
```

Проще говоря, объявление переменных и функций "перемещается" вверх по коду. Это и называется "Хостинг".

Важно отметить, что хостинг работает в рамках скоупа. Все предыдущие примеры были простыми и имели только один скоуп - глобальный. Рассмотрим пример:

``` javascript
foo();

function foo() {
    console.log( a ); // undefined

    var a = 2;
}
```
В функции `foo` переменная `a` хостится в начале функции, таким образом, код можно проинтерпретировать так:
```
function foo() {
    var a;

    console.log( a ); // undefined

    a = 2;
}

foo();
```
Function declarations, как мы только что видели, всплывает. А вот function expressions нет:
``` javascript
foo(); // not ReferenceError, but TypeError!

var foo = function bar() {
    // ...
};
```
Идентификатор переменной `foo` всплывает и закрепляется в глобальном скоупе, поэтому вызов `foo()` не порождает `ReferenceError`. Но к моменту вызова в переменной `foo` еще нет значения. Поэтому, мы пытаемся вызвать функцию от `undefined` и получаем `TypeError`.

### Порядок объявления функций
Объявления функций и объявления переменных всплывают, однако есть разница, которая проявляется только в случае, если мы объявили с одним именем функцию и переменную, как в примере ниже:
``` javascript
foo(); // 1

var foo;

function foo() {
    console.log( 1 );
}

foo = function() {
    console.log( 2 );
};
```
Сначала объявляются функции, а только потом переменные. Этот листинг интерпретируется как:
``` javascript
function foo() {
    console.log( 1 );
}

foo(); // 1

foo = function() {
    console.log( 2 );
};
```
Следует отметить, что `var foo` повторяется и поэтому второй раз игнорируется, хоть он и произощел раньше чем `function foo()...`  поскольку объявление функций происходит до того как объявляются переменные.

Множественные повторые объявления также игнорируются, функции, которые были объявлены позже, переопределяют более ранние объявления, как показано на примере ниже:
``` javascript
foo(); // 3

function foo() {
    console.log( 1 );
}

var foo = function() {
    console.log( 2 );
};

function foo() {
    console.log( 3 );
}
```
Все может звучать как академических пустяк, однако подчеркивает тот факт, что повторяющиеся определения в одной и той же области, являются весьма плохой идеей, и часто приводят к противоречивым результатам.

Объявления функций, которые появляются внутри блоков поднимаются к внешней области видимости по порядку, а не условно, как этот код подразумевает:
``` javascript
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```
Однако, важно отметить, что такое поведение не является надежным и может изменяться в будущих версиях JavaScript, поэтому наверное, лучше не объявлять функции в блоках.

## Замыкание
**Когда вы пишите код на JavaScript, замыкание повсюду вокруг вас, это надо признать и принять как есть** Замыкание происходит в результате написания кода который основывается на лексическом скоупе. Вы можете даже не понимать что это замыкание и пользоваться им.

Определение замыкания звучит так:
>> Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.


>> Замыкание - это когда функция находится в состоянии запомнить и предоставить доступ к лексическому скоупу даже при том, что функция выполняется за пределами своей лексической области видимости.


Обратимся к следующему коду для иллюстрации сказанного:
``` javascript
function foo() {
    var a = 2;

    function bar() {
        console.log( a ); // 2
    }

    bar();
}

foo();
```
Функции `bar()` получает доступ к переменной `a` в наружной области видимости используя правила поиска.
Это академический пример, давайте рассмотрим следующий фрагмент кода, в котором замыкания показывают себя во всей своей красе:
``` javascript
function foo() {
    var a = 2;

    function bar() {
        console.log( a );
    }

    return bar;
}

var baz = foo();

baz(); // 2 -- Whoa, closure was just observed, man.
```
Функция `bar()` имеед доступ к лексическому скоупу функции `foo()`. Но вместо того чтобы вызвать функцию, мы передаем ее как значение. В этом случае, мы вернем функцию которая ссылается на `bar`.

После того как мы выполним функцию `foo()` получим ссылку на значение которое вернула функция в переменной `baz`. Когда мы выполняем `baz()` мы тем самым выполняем внутреннюю функцию `bar`, но уже в другом окружении.

После того как функция `foo()` выполнится, мы ожидаем что ее внутренний скоуп пропадет, потому что интерпритатор позовет сборщик мусора который освобождает память которая больше не используется. Кажется, что сожержимое функции `foo` никем больше не используется и кажется естественным что сборщик мусора его удалит.

Но "магия" замыканий не позволить этому случиться. То, что внутри скоупа по сути еще "используется", и таким образом не уходит. Кто пользуется? Функция `bar`. Она по прежнему имеет ссылку на скоуп функции `foo` и эта ссылка называется замыканием.

Поэтому, когда выполняется переменная `baz` она имеет доступ к другому лексическому скоупу, а не только к тому в котором выполняется, а значит получает доступ к переменной `a` как мы и ожидали.

Функция выполняется вне контекста, в котором была объявленна. Одако, замыкание позволяет получить доступ к лексической области видимости, которая была доступна во время объявления.

Конечно, существует несколько способов с помощью которыйх функция может быть передана вовне и затем выполнена в другом лексическом скоупе:
``` javascript
function foo() {
    var a = 2;

    function baz() {
        console.log( a ); // 2
    }

    bar( baz );
}

function bar(fn) {
    fn(); // look ma, I saw closure!
}
```
Мы передаем внутреннюю функцию `baz` вне `bar` и когда мы вызываем ее (теперь она называется `fn`) то наблюдаем замыкание на внутренний скоуп функции `foo()`, получая доступ к переменной `a`.

Передавать функцию в другой скоуп можно также косвенно, например:
``` javascript
var fn;

function foo() {
    var a = 2;

    function baz() {
        console.log( a );
    }

    fn = baz; // assign `baz` to global variable
}

function bar() {
    fn(); // look ma, I saw closure!
}

foo();

bar(); // 2
```
Какой бы способ передачи мы не выбрали, будет ссылка на оригинальный скоуп, и поэтому выполняя функцию мы получим доступ к нужным переменным.

Предыдущие фрагменты кода были несколько академичными и искусственно сконструированными, чтобы проиллюстрировать замыкание. Как мы уже отметили, замыкание вокруг вас и его можно найти в вашем коде. Обратимся к примеру:

``` javascript
function wait(message) {

    setTimeout( function timer(){
        console.log( message );
    }, 1000 );

}

wait( "Hello, closure!" );
```

У нас есть внутренняя функция `timer` которая передается в `setTimeout(..)`. И `timer` имеет доступ к скоупу в котором доступна переменная `message`.

Спустя секунду после того как мы выполнили `wait(..)` и его лексический скоуп уже давно никем не использовался, анонимная функция замыкается на него.

Глубоко во внутренностях интерпретатора, встроенная утилита `setTimeout(..)` содержит ссылку на некоторый параметр (который называется fn или func или както еще). Интерпретатор вызывает эту функцию, которая вызывает наш внутренний `timer` при этом ссылка на лексический контекст еще цела.

### Циклы и замыкание
Самый распространенный канонический пример используется для иллюстрации замыкания предполагает обычный цикл for.
``` javascript
for (var i=1; i<=5; i++) {
    setTimeout( function timer(){
        console.log( i );
    }, i*1000 );
}
```

Подвох этого кода закючается в том, что мы ожидаем, что увидим цифры"1", "2", .. "5" по одной, раз в секунду, соответственно. На самом деле, если вы запустите этот код, вы получаете "6" распечатанные 5 раз, с односекундным интервалом.

Во-первых, давайте поймем откуда берется 6 - это первое значение которое не удовлетворяет условию цикла `i<=5`.

На самом деле, на второй взгляд, это кажется очевидным, поскольку все таймаут функции выполнятся уже после выхода из цикла. И это было бы правдой даже если бы мы вызывали `setTimeout(.., 0)` на каждом шаге цикла.

Но чего не хватает в нашем коде, для того чтобы он вел себя так, как мы этого семантически предполагаем? Чего не хватает, чтобы мы захватывали на каждом шаге цикла свое собственное значение `i` и выполняли колбек с ним?

Нам не хватает замыкания, а именно на каждом шаге цикла мы хотим иметь новы скоуп с нужным значением. А именно:
``` javascript
for (var i=1; i<=5; i++) {
    (function(){
        var j = i;
        setTimeout( function timer(){
            console.log( j );
        }, j*1000 );
    })();
}
```
или
``` javascript
for (var i=1; i<=5; i++) {
    (function(j){
        setTimeout( function timer(){
            console.log( j );
        }, j*1000 );
    })( i );
}
```
Проблема решена :)

### Утечки памяти

Если сделать любую вложенную функцию доступной вне тела функции, в которой она была создана, образуется замыкание. Поэтому замыкания очень легко создать, в результате чего javascript разработчики, которые не понимают, что замыкание — это особенность языка, используют без явных последствий вложенные функции для различных задач, не осознавая, что были созданы замыкания или какие могут быть последствия.

Случайное создание замыканий может иметь побочные эффекты, как, например, описанная в следующем разделе проблема утечки памяти в IE; они также могут влиять на эффективность кода. Причина не в самих замыканиях, на самом деле, при аккуратном использовании, они могут значительно способствовать созданию эффективного кода. Дело во вложенных функциях, использование которых может отразиться на эффективности.

Не нужно без необходимости создавать функции внутри функций в тех случаях, когда замыкания не нужны. Использование этой техники увеличивает требования к производительности как в части скорости, так и в части потребления памяти.

### Когда нужно применять замыкание

#### Сохранение контекста между вызовами:

``` javascript
function createCounter() {
   var numberOfCalls = 0;
   return function() {
      return ++numberOfCalls;
   }
}
var fn = createCounter();
fn(); //1
fn(); //2
fn(); //3
```

#### метапрограммирование
Другое хорошее применение замыканий — создание функций, в свою очередь тоже создающих функции — то, что некоторые назвали бы приёмом т.н. метапрограммирования. Например:
``` javascript
var createHelloFunction = function(name) {
   return function() {
      alert('Hello, ' + name);
   }
}
var sayHelloHabrahabr = createHelloFunction('Habrahabr');
sayHelloHabrahabr(); //alerts «Hello, Habrahabr»
```
Благодаря замыканию возвращаемая функция «запоминает» параметры, переданные функции создающей, что нам и нужно для подобного рода вещей.

Похожая ситуация возникает, когда мы внутреннюю функцию не возвращаем, а вешаем на какое-либо событие — поскольку событие возникает уже после того, как исполнилась функция, замыкание опять же помогает не потерять переданные при создании обработчика данные.

#### инкапсуляция
``` javascript
(function() {
   …
})();
```
Очевидно, внутри замыкания мы имеем доступ ко всем внешним данным, но при этом оно имеет и собственные. Благодаря этому мы можем окружать части кода подобной конструкцией с целью закрыть попавшие внутрь локальные переменные от доступа снаружи.

Есть, правда, одна связанная с таким применением ловушка — внутри замыкания теряется значение слова this за его пределами. Решается она следующим образом:
``` javascript
(function() {
   //вышестоящее this сохранится
}).call(this);
```

### Заключение
Замыкания — это очень интересный и крайне полезный прием программирования. Суть замыкания можно выразить так: в функции доступны все переменные той области видимости, в которой она была определена.

Замыкания позволяют реализовывать аналог приватных переменных, минимизировать выход переменных в глобальную область видимости. С другой стороны, неаккуратное использование замыканий может привести к побочным эффектам, описанным выше. Поэтому использовать их стоит крайне внимательно.

### Ссылки на материал
* [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20&%20closures/README.md#you-dont-know-js-scope--closures)
* [learn.javascript.ru](https://learn.javascript.ru/closures)
* [habrahabr.ru/post/38642/](http://habrahabr.ru/post/38642/)
* [getinstance.info](http://getinstance.info/articles/javascript/closures-in-javascript/)
* [developer.mozilla.org](https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures)
