# Функции.

Функции в JavaScript. Возврат значения. Параметры.

## Объявление и вызов функции

Один из способ объявления функции выглядит так.

```js
function add(x, y) {
    return x + y;
}
```

Мы объявляем функцию `add` с двумя параметрами — `x` и `y`. Функция возвращает сумму этих параметров.

Вызов функции выполняется следующим образом.

```js
add(2, 3); // 5
```

Если явно не указывать возвращаемое значение, как в этом примере, функция вернёт `undefined`.

```js
function lazy() {
}

lazy(); // undefined
```

## Аргументы функции

Функции можно вызывать с любым количеством аргументов. 

Если параметр не передан при вызове, ему будет присвоено значение `undefined`.

```js
function asIs(x) { 
    return y;
}

asIs(y); // undefined
```

То же самое справедливо для функции с несколькими аргументами.

```js
function myMin(a, b) {
    return a < b ? a : b;
}

myMin(2, 7); // 2
myMin(13, 7); // 7
myMin(13); // undefined
```

Мы можем проверить, передан ли параметр, и если нет, задать ему значение по умолчанию.

```js
function myMin(a, b) {
    if (b === undefined) {
        return a;
    }

    return a < b ? a : b;
}

myMin(13); // 13
```

При объявлении функции необязательные аргументы, как правило, располагают в конце списка.

Зачастую для задания значения по умолчанию используют более короткую форму с импользованием оператора `||`.

```js
function myMin(a, b) {
    b = b || Infinity;

    return a < b ? a : b;
}

myMin(2, 7); // 2
myMin(13, 7); // 7
myMin(-13); // -13
```

Этот способ следует использовать с осторожностью. Если параметр может принимать значения, приводимые к `false` — например, `0`, `''` или `null`, они будут перезаписаны значением по умолчанию.

```js
function getSalary(rate, days) {
    days = days || 22;

    return rate * days;
}

getSalary(3, 10); // 30
getSalary(1); // 22
getSalary(2, 0); // 44 ???
```

В некоторых языках (например, в _python_), при вызове функции можно передавать именованные аргументы.

```python
add(x=2, y=3);
```

Это удобно по нескольким причинам. Во-первых, в момент вызова мы видим, для чего используется тот или иной аргумент. Во-вторых, становится неважным порядок передачи аргументов. Это особенно удобно, когда у функции есть несколько необязательных аргументов.

В JavaScript мы можем имитировать именованные аргументы с помощью литерала объекта.

```js
BMI({ m: 60, h: 1.7 }) // 20.7
```

Обратите внимание на скобки — на самом деле мы передаём в функцию один аргумент — объект, свойствами которого являются наши как-бы именованные аргументы.

Объявление функции будет выглядеть слудующим образом.

```js
function BMI(params) {
    var h = params.h;

    return params.m / (h * h);
}
```

Однако, у такого подхода есть несколько недостатков:

* аргументы нужно вызывать через точку (как свойства объекта)
* по сигнатуре функции нельзя понять, с какими параметрами она вызывается

Поэтому такой подход не следует использовать повсеместно. На практике его обычно применяют, когда функция принимает большое количество необязательных конфигурационных параметров.

Мы также можем передать больше аргументов, чем определено в функции. Избыточные аргументы будут проигнорированы.

```js
function myMin(a, b) {
    return a < b ? a : b;
}

myMin(7, 5, 1); // 5
```

Внутри функции доступна специальная переменная `arguments`, которая позволяет получить доступ ко всем переданным аргументам.

```js
function myMin(a, b) {
    var min = a < b ? a : b;
    var c = arguments[2];

    return c < min ? c : min;
}

myMin(2, 3, 4); // 2
myMin(20, 3, 4); // 3
myMin(20, 30, 4); // 4
```

С его помощью мы можем объявить функцию, принимающую любое количество аргументов.

Например, эта функция суммирует все переданные при вызове числа.

```js
function addMany()
{
    var sum = 0;
    var len = arguments.length;

    for (var i = 0; i < len; i += 1) {
        sum += arguments[i];
    }

    return sum;
}

addMany(2, 3, 4); // 9
```

По историческим причинам `arguments` — не массив, а так называемый _array-like object_. Поэтому у него нет методов массива, таких как `forEach` или `map`.

К счастью, есть способ преобразовать его к массиву с помощью следующей конструкции.

```js
var args = [].slice.call(arguments);
```

Тут нам играет на руку динамическая природа языка JavaSctipt. Нам понадобится метод `slice`, который может использоваться для копирования массива. Мы берём этот метод у только что созданного массива, и вызываем его на нашем объекте.

Эта конструкция аналогична следующей:

```js
// не надо использовать этот код
// он здесь только для наглядного описания

arguments.slice = [].slice;
var args = arguments.slice();
```

В следующих лекциях мы более подробно поговорим о методе `call`.

## Методы функции

Рассмотрим следующий пример. Нам нужно найти минимальное значение из элементов, которые лежат в массиве `numbers`.

```js
Math.min(3, 5, 2, 6); // 2

var numbers = [3, 5, 2, 6];
Math.min(numbers); // NaN
```

У нас есть функция `Math.min`, но она принимает несколько аргументов. Если просто передать массив в функцию — результат будет отличаться от наших ожиданий.

На помощь нам приходит метод `apply`.

Первым аргументом метод принимает так называемый контекст — объект, на который будет указывать ключевое слово `this` внутри функции. О контексте и ключевом слове `this` мы подробнее поговорим в следующих лекциях, а пока просто передадим первым аргументом `null`.

В качестве второго аргумента метод принимает массив, элементы которого будут переданы в функцию.

```js 
var numbers = [3, 5, 2, 6];
Math.min.apply(null, numbers); // 2
```

Другой полезный метод — `bind`, позволяет выполнить так называемое частичное применение функции.

Частичное применение — это процесс предачи части аргументов функции, который возвращает другую функцию, принимающую оставшиеся аргументы (функцию меньшей арности).

Рассмотрим функцию возведения в степень — `Math.pow`. Она принимает два аргумента.

```js
Math.pow(2, 4); // 16
Math.pow(2, 10); // 1024
```

C помощью метода `bind` мы можем передать только первый аргумент и получить функцию, возводящую в степень определённой число — в нашем случае, двойку.

```js
var binPow = Math.pow.bind(null, 2);

binPow(4); // 16
binPow(10); // 1024
```

## Функции — объекты первого класса

Функции в JavaScript являются объектами первого класса. Это значит, что функции являются таким же полноценным типом данных, как число, строка или объект. 

Функцию можно положить в переменную:

```js
function add(a, b) {
    return a + b;
}

var sum = add;
sum(1, 3); // 4
```

Функуию можно передать в качестве аргумента другой функции:

```js
function multiplyBy2(x) {
    return x * 2;
}

var numbers = [3, 5, 9];

numbers.map(multiplyBy2); // [6, 10, 18] 
```

Наконец, функция может быть возвращена результате выполнения другой функции:

```js
function getAdd() {
    function add(a, b) {
        return a + b;
    }

    return add;
}

var myAdd = getAdd();
myAdd(1, 3); // 4
```

## Способы объявления функции

В начале лекции мы говорили об одном способе объявления функции. Он называется _function declaration_.

```js
function add(x, y) {
    return x + y;
}
```

Функция, определённая таким образом, создаётся на этапе интерпретации программы, то есть ещё до начала выполнения кода.

Это приводит к эффекту, называемому _hoisting_, то есть всплытие или подём. Проявляется он в том, что функцию можно вызывать до её объявления.

```js
add(2, 3); // 5

function add(x, y) {
    return x + y;
}
```

Это происходит потому, что интерпретатор поднимает объявление функции над выполняемым кодом, и исходный код приобретает следующий вид:

```js
function add(x, y) {
    return x + y;
}

add(2, 3);
```

Второй способ объявления функции называется _function expression_ и выглядит так:

```js
var add = function (x, y) {
    return x + y;
};
```

В этом примере мы создаём функцию без имени — так называемую "анонимную функцию" и кладём её в переменную `add`.

Несмотря на общую схожесть с предыдущим вариантом, есть одно существенное различие — эта функция создаётся в момент выполнения кода, поэтому её нельзя использовать до определения.

```js
add(2, 3); // TypeError: add is not a function

var add = function (x, y) {
    return x + y;
};
```

Функция, объявленная с помощью _function expression_, не обязательно должна быть анонимной. Мы можем указать для неё идентификатор.

```js
var add = function hidden() {
    return typeof hidden;
}

add(); // function
```

В отличие от _function declaration_, такой идентификатор будет доступен только внутри функции, но не виден снаружи.

```js
var add = function hidden() {
    return typeof hidden;
}

hidden(); // ReferenceError: hidden is not defined
```

Это может быть полезно при определении рекурсивных функций. Такие функции могут вызывать сами себя.

Для примера рассмотрим функцию вычисления факториала.

```js
var fac = function me(n) {
    if (n > 0) {
        return n * me(n-1);
    } else {
        return 1;
    }
};
console.log(fac(3)); // 6
```

Мы рассмотрели два варианта объявления функции. Какой из них лучше?

```js
function add(x, y) {
    return x + y;
}

var add = function (x, y) {
    return x + y;
};
```

Оба варианта полностью допустимы. В общем случае можно использовать первый спобоб — _function declaration_. Этот способ обладает более простым синтаксисом, а также позволяет использовать эффект всплытия.

Есть и ещё один способ объявить функцию, но он встречается достаточно редко.

```js
> var add = new Function('x', 'y', 'return x + y');
> add(2, 3)
5
```

Мы можем использовать конструктор `Function`. Этот способ может пригодиться, если требуется создать тело функции на этапе выполнения кода.

## Область видимости функции

Область видимости переменной — это часть кода, в пределах которой эта переменная доступна.

В Javascript область видимости переменной ограничивается функцией.

```js
function greet() {
    var text = 'Привет';

    console.log(text);
}

greet(); // 'Привет'
console.log(text); // Uncaught ReferenceError: text is not defined
```

Определяя функцию внутри другой функции, мы создаём новую область видимости. Переменная из внешней области видимости доступна во вложенной

```js
function greet() {
    var text = 'Привет';

    function nested() {
        console.log(text);
    }

    nested();
}

greet(); // 'Привет'
```

Если во внутренней области видимости объявить переменную с тем же именем, что и во внешней, она перекроет переменную из внешней области видимости. Этот эффект называется shadowing (затенение).

```js
function greet() {
    var text = 'Привет';

    function nested() {
        var text = 'Добрый день';

        console.log(text);
    }

    nested();
}

greet(); // 'Добрый день'
```

В отличие от других языков, блок не создаёт область видимости:

```js
function greet() {
    if (true) {
        var text = 'Привет';
    }

    console.log(text); // 'Привет'
}
```

В этом примере срабатывает механизм всплытия, о котором мы говорили ранее.

Интерпретатор поднимает объявление переменной к началу области видимости, то есть к началу функции:

```js
function greet() {
    var text;

    if (true) {
        text = 'Привет';
    }

    console.log(text); // 'Привет'
}
```

Иногда возникает необходимость искуственно создать область видимости. Например, если мы хотим ограничить доступ к некторым переменным.

Для этого можно использовать способ, называемый "немедленно вызываемой функцией" или IIFE (immediately-invoked function expression).

```js
function foo() {
    (function () {
        var bar = 4;
    }());

    console.log(bar); // Reference Error
}
```

Мы создаём функцию, чтобы ввести новую область видимости. И сразу же после создания вызываем её.

Скобки фокруг функции нужны для того, чтобы интерпретатор понял, что мы хотим использовать _function expression_.

```js
function () {
    
}()

// SyntaxError: Unexpected token (
```

Если попробовать немедленно вызвать функцию, объявленную с помощью  _function declaration_, мы получим ошибку синтаксиса — язык не разрешает такую конструкцию.

Чтобы исправить ситуацию, нам нужно поместить любой символ перед ключевым словом `function`. Сделать это мы можем любым способом:

```js
!function () {
}();

void function () {
}();
```

## Новые возможности языка

Рассмотрим возможности, которы вносит новый стандарт языка ECMAScript 2015.

### Блочная область видимости

Для создания области видимости нужно было использовать IIFE.

```js
function foo() {
    (function () {
        var bar = 4; 
    }());
}
```

Теперь можно объявить переменную с блочной областью видимости с помощью ключевого слова `let`.

```js
function foo() {
    if (true) {
        let bar = 4; 
    }
}
```

### Значения параметра по умолчанию

Для того, чтобы установить значение параметра по умолчанию, нужно было проверять его значение.

```js
function add(x, y) {
    if (y === undefined) {
        y = 0;
    }

    return x + y;
}
```

Теперь можно задать значение по умолчанию в сигнатуре функции.

```js
function add(x, y = 0) {
    return x + y;
}
```

### Функции с произвольным числом аргументов

Для доступа к произвольному числу аргументов нужно было обращаться к переменной `arguments`.

```js
function add() {
    var sum = 0;

    for (var i, l = arguments.length; i < l; i += 1) {
        sum += arguments[i];
    }

    return sum;
}
```

Теперь можно использовать оператор `...` чтобы получить массив переданных аргументов.

```js
function add(...args) {
    var sum = 0;

    args.forEach(function (arg) {
        sum += arg;
    });

    return sum;
}
```

### Destructuring

Одним из недостатков именованных аргументов являлась необходимость обращаться к параметрам через точку.

```js
function add(options) {
    return options.x + options.y;
}

add({ x: 1, y: 2});
```

Теперь мы можем извлечь значения из переданного объекта прямо в сигнатуре функции:

```js
function add({ x, y }) {
    return x + y;
}

add({ x: 1, y: 2});
```
